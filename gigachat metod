package com.exhibition.enterprise.service.viewing;

import com.exhibition.enterprise.annotation.LogExecutionTime;
import com.exhibition.enterprise.annotation.ValidateInput;
import com.exhibition.enterprise.config.ViewingProperties;
import com.exhibition.enterprise.dto.ViewingRequestDTO;
import com.exhibition.enterprise.dto.ViewingResponseDTO;
import com.exhibition.enterprise.exception.GlassesNotFoundException;
import com.exhibition.enterprise.exception.ViewerSleepingException;
import com.exhibition.enterprise.fallback.GlassesServiceFallback;
import com.exhibition.enterprise.handler.ViewingHandler;
import com.exhibition.enterprise.handler.impl.*;
import com.exhibition.enterprise.mapper.ViewingMapper;
import com.exhibition.enterprise.model.*;
import com.exhibition.enterprise.repository.PictureViewingRepository;
import com.exhibition.enterprise.strategy.ViewingStrategy;
import com.exhibition.enterprise.strategy.impl.FunnyPictureStrategy;
import com.exhibition.enterprise.strategy.impl.SeriousPictureStrategy;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * Сервис для обработки просмотра картин с поддержкой enterprise-паттернов.
 * Использует Chain of Responsibility, Strategy, Circuit Breaker, Retry механизмы.
 */
@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class PictureViewingEnterpriseService implements PictureViewingService {
    
    private final ViewingProperties viewingProperties;
    private final PictureViewingRepository viewingRepository;
    private final ViewingMapper viewingMapper;
    private final GlassesServiceFallback glassesServiceFallback;
    private final AnalyticsServiceClient analyticsServiceClient;
    
    private List<ViewingHandler> viewingHandlers;
    
    @PostConstruct
    public void initHandlers() {
        this.viewingHandlers = List.of(
            new SleepingHandler(),
            new NullCheckHandler(),
            new GlassesAvailabilityHandler(glassesServiceFallback),
            new FunnyPictureHandler(viewingProperties.getLaughThreshold()),
            new GlassesWearingHandler(),
            new StatisticsUpdateHandler(viewingRepository)
        );
        
        log.info("Viewing handlers chain initialized with {} handlers", viewingHandlers.size());
    }
    
    /**
     * Просмотр картины с enterprise-функционалом.
     * 
     * @param requestDTO DTO с данными для просмотра
     * @return ViewingResponseDTO с результатом просмотра
     */
    @Override
    @Async("viewingTaskExecutor")
    @CircuitBreaker(name = "viewingService", fallbackMethod = "fallbackViewPicture")
    @Retry(name = "viewingService", fallbackMethod = "retryFallback")
    @Cacheable(value = "viewingResults", key = "#requestDTO.hashCode()")
    @LogExecutionTime
    @ValidateInput
    @Transactional
    public ViewingResponseDTO watchPicture(ViewingRequestDTO requestDTO) {
        log.info("Processing enterprise viewing request: {}", requestDTO.getRequestId());
        
        ViewingContext context = ViewingContext.builder()
            .viewer(requestDTO.getViewer())
            .picture(requestDTO.getPicture())
            .startTime(System.currentTimeMillis())
            .build();
        
        // Chain of Responsibility
        for (ViewingHandler handler : viewingHandlers) {
            if (!handler.handle(context)) {
                log.warn("Viewing interrupted by handler: {}", handler.getClass().getSimpleName());
                return buildErrorResponse(context, "INTERRUPTED_BY_HANDLER");
            }
        }
        
        // Strategy Pattern для разных типов картин
        ViewingStrategy strategy = context.getPicture().isFunny() 
            ? new FunnyPictureStrategy(viewingProperties)
            : new SeriousPictureStrategy();
        
        strategy.execute(context);
        
        // Отправка аналитики
        analyticsServiceClient.sendViewingAnalytics(context);
        
        return buildSuccessResponse(context);
    }
    
    /**
     * Fallback метод при сбое Circuit Breaker.
     */
    public ViewingResponseDTO fallbackViewPicture(ViewingRequestDTO requestDTO, Throwable t) {
        log.error("Circuit Breaker triggered for viewing request: {}", requestDTO.getRequestId(), t);
        return ViewingResponseDTO.builder()
            .success(false)
            .errorCode("CIRCUIT_BREAKER_TRIGGERED")
            .errorMessage("Service temporarily unavailable")
            .build();
    }
    
    /**
     * Fallback метод после исчерпания попыток Retry.
     */
    public ViewingResponseDTO retryFallback(ViewingRequestDTO requestDTO, Throwable t) {
        log.error("Retry exhausted for viewing request: {}", requestDTO.getRequestId(), t);
        return ViewingResponseDTO.builder()
            .success(false)
            .errorCode("RETRY_EXHAUSTED")
            .errorMessage("Maximum retry attempts reached")
            .build();
    }
    
    private ViewingResponseDTO buildSuccessResponse(ViewingContext context) {
        return ViewingResponseDTO.builder()
            .success(true)
            .viewerName(context.getViewer().getName())
            .pictureName(context.getPicture().getName())
            .wasFunny(context.getPicture().isFunny())
            .glassesWorn(context.getViewer().hasGlassesOn())
            .laughCount(context.getViewer().getLaughCount().get())
            .processingTime(System.currentTimeMillis() - context.getStartTime())
            .build();
    }
    
    private ViewingResponseDTO buildErrorResponse(ViewingContext context, String errorCode) {
        return ViewingResponseDTO.builder()
            .success(false)
            .errorCode(errorCode)
            .viewerName(context.getViewer().getName())
            .pictureName(context.getPicture().getName())
            .build();
    }
}

/**
 * Контекст для Chain of Responsibility.
 */
@Data
@Builder
class ViewingContext {
    private DrPilulkin viewer;
    private Picture picture;
    private long startTime;
    private boolean shouldContinue;
    private String interruptionReason;
}

/**
 * Базовый обработчик в цепочке ответственности.
 */
abstract class BaseViewingHandler implements ViewingHandler {
    @Override
    public boolean handle(ViewingContext context) {
        if (canHandle(context)) {
            return process(context);
        }
        return true; // Продолжаем цепочку
    }
    
    protected abstract boolean canHandle(ViewingContext context);
    protected abstract boolean process(ViewingContext context);
}
