package com.exhibition.production.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StopWatch;

import javax.annotation.PostConstruct;
import java.time.Duration;
import java.time.Instant;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.LongAdder;

/**
 * Production-ready реализация метода watchPicture() для промышленного использования.
 * Включает: кэширование, retry, circuit breaker, метрики, логирование, graceful degradation.
 */
@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class ProductionPictureViewingService {
    
    // ========== КОНФИГУРАЦИЯ ==========
    @Value("${viewing.glasses.threshold:3}")
    private int glassesThreshold;
    
    @Value("${viewing.retry.max-attempts:3}")
    private int maxRetryAttempts;
    
    @Value("${viewing.cache.ttl-seconds:300}")
    private long cacheTtlSeconds;
    
    @Value("${viewing.circuit-breaker.failure-threshold:5}")
    private int circuitBreakerThreshold;
    
    @Value("${viewing.timeout.ms:10000}")
    private long operationTimeout;
    
    @Value("${viewing.metrics.enabled:true}")
    private boolean metricsEnabled;
    
    @Value("${viewing.degradation.enabled:true}")
    private boolean gracefulDegradationEnabled;
    
    // ========== СЕРВИСЫ И КОМПОНЕНТЫ ==========
    private final PictureRepository pictureRepository;
    private final ViewerRepository viewerRepository;
    private final GlassesService glassesService;
    private final AnalyticsService analyticsService;
    private final MetricsCollector metricsCollector;
    private final CircuitBreakerRegistry circuitBreakerRegistry;
    
    // ========== СОСТОЯНИЕ ==========
    private final ConcurrentHashMap<String, ViewingCacheEntry> viewingCache = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, AtomicInteger> failureCounters = new ConcurrentHashMap<>();
    private final LongAdder totalViewings = new LongAdder();
    private final LongAdder successfulViewings = new LongAdder();
    private final LongAdder failedViewings = new LongAdder();
    private volatile boolean circuitBreakerOpen = false;
    private Instant lastCircuitBreakerCheck = Instant.now();
    
    @PostConstruct
    public void init() {
        log.info("ProductionPictureViewingService initialized with glasses threshold: {}", glassesThreshold);
        startMetricsCollector();
    }
    
    // ========== ОСНОВНОЙ МЕТОД ==========
    
    /**
     * Production-реализация метода watchPicture() с полной обработкой edge cases.
     * 
     * @param viewerId ID зрителя
     * @param pictureId ID картины
     * @param operationId ID операции (для трассировки)
     * @return Результат просмотра
     */
    @Async("viewingTaskExecutor")
    @Retryable(
        value = {TemporaryServiceException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 100, multiplier = 2, maxDelay = 1000)
    )
    @Cacheable(value = "viewingResults", key = "#viewerId + ':' + #pictureId", 
               unless = "#result.errorCode != null")
    public CompletableFuture<ViewingResult> watchPicture(String viewerId, String pictureId, String operationId) {
        // Генерация operationId если не предоставлен
        String opId = Optional.ofNullable(operationId)
            .orElse(generateOperationId(viewerId, pictureId));
        
        totalViewings.increment();
        
        // Проверка circuit breaker
        if (isCircuitBreakerOpen()) {
            log.warn("Circuit breaker is OPEN, rejecting request: {}", opId);
            failedViewings.increment();
            return CompletableFuture.completedFuture(
                ViewingResult.failure("CIRCUIT_BREAKER_OPEN", "Service temporarily unavailable")
            );
        }
        
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        try {
            // Валидация входных данных
            validateInput(viewerId, pictureId, opId);
            
            // Проверка кэша
            Optional<ViewingResult> cachedResult = checkCache(viewerId, pictureId, opId);
            if (cachedResult.isPresent()) {
                return CompletableFuture.completedFuture(cachedResult.get());
            }
            
            // Загрузка данных с проверкой существования
            Viewer viewer = viewerRepository.findById(viewerId)
                .orElseThrow(() -> new ViewerNotFoundException("Viewer not found: " + viewerId));
            Picture picture = pictureRepository.findById(pictureId)
                .orElseThrow(() -> new PictureNotFoundException("Picture not found: " + pictureId));
            
            // Проверка состояния зрителя с graceful degradation
            if (viewer.isSleeping() && !isGracefulDegradationAllowed()) {
                log.info("Viewer {} is sleeping, skipping: {}", viewerId, opId);
                metricsCollector.recordSkippedViewing(viewerId, "SLEEPING");
                return CompletableFuture.completedFuture(
                    ViewingResult.skipped("VIEWER_SLEEPING", "Viewer is sleeping")
                );
            }
            
            // Основная бизнес-логика с таймаутом
            ViewingResult result = executeViewingWithTimeout(viewer, picture, opId);
            
            // Успешное завершение
            successfulViewings.increment();
            recordSuccess(opId);
            
            // Кэширование результата
            cacheResult(viewerId, pictureId, result);
            
            // Асинхронная отправка аналитики
            sendAnalyticsAsync(viewer, picture, result, opId);
            
            stopWatch.stop();
            log.debug("Viewing completed in {}ms: {}", stopWatch.getTotalTimeMillis(), opId);
            
            return CompletableFuture.completedFuture(result);
            
        } catch (BusinessException e) {
            // Ожидаемые бизнес-ошибки
            stopWatch.stop();
            log.warn("Business error in viewing {}: {}", opId, e.getMessage());
            failedViewings.increment();
            recordFailure(viewerId, pictureId);
            metricsCollector.recordViewingError(e.getErrorCode());
            
            return CompletableFuture.completedFuture(
                ViewingResult.failure(e.getErrorCode(), e.getMessage())
            );
            
        } catch (Exception e) {
            // Неожиданные ошибки
            stopWatch.stop();
            log.error("Unexpected error in viewing {}: {}", opId, e.getMessage(), e);
            failedViewings.increment();
            recordFailure(viewerId, pictureId);
            metricsCollector.recordUnexpectedError(e);
            
            if (gracefulDegradationEnabled) {
                // Graceful degradation: возвращаем деградированный результат
                return CompletableFuture.completedFuture(
                    ViewingResult.degraded("SERVICE_UNAVAILABLE", 
                        "Service degraded, viewing may be incomplete")
                );
            }
            
            throw new ViewingServiceException("Failed to process viewing: " + opId, e);
        } finally {
            // Обновление метрик производительности
            if (stopWatch.isRunning()) {
                stopWatch.stop();
            }
            if (metricsEnabled) {
                metricsCollector.recordOperationDuration(opId, stopWatch.getTotalTimeMillis());
            }
        }
    }
    
    // ========== ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ==========
    
    private ViewingResult executeViewingWithTimeout(Viewer viewer, Picture picture, String opId) {
        Instant startTime = Instant.now();
        
        // Проверка доступности очков с таймаутом
        boolean glassesAvailable = checkGlassesAvailabilityWithTimeout(viewer, opId);
        
        // Основная логика
        boolean wasFunny = picture.isFunny();
        AtomicInteger laughCount = viewer.getLaughCount();
        
        if (wasFunny) {
            int newLaughCount = laughCount.incrementAndGet();
            log.debug("Viewer {} laughed at {} (count: {}): {}", 
                viewer.getName(), picture.getName(), newLaughCount, opId);
            
            // Надевание очков при достижении порога
            if (newLaughCount >= glassesThreshold && glassesAvailable && !viewer.hasGlassesOn()) {
                tryPutOnGlassesWithRetry(viewer, opId);
            }
        }
        
        // Обновление статистики с блокировкой для thread safety
        synchronized (picture) {
            picture.incrementViewCount();
            picture.addViewerReaction(viewer.getId(), 
                wasFunny ? "LAUGHED_" + viewer.getId() : "VIEWED_" + viewer.getId());
        }
        
        // Сохранение с оптимистичной блокировкой
        viewerRepository.save(viewer);
        pictureRepository.save(picture);
        
        // Сбор метрик
        ViewingMetrics metrics = collectMetrics(viewer, picture, startTime, wasFunny, opId);
        
        return ViewingResult.success(
            viewer.getId(),
            picture.getName(),
            wasFunny,
            viewer.hasGlassesOn(),
            laughCount.get(),
            metrics
        );
    }
    
    private boolean checkGlassesAvailabilityWithTimeout(Viewer viewer, String opId) {
        if (!glassesService.isAvailable()) {
            log.debug("Glasses service unavailable, skipping glasses check: {}", opId);
            return false;
        }
        
        try {
            return glassesService.checkAvailability(viewer.getGlassesId())
                .completeOnTimeout(false, Duration.ofMillis(operationTimeout / 2))
                .thenApply(available -> {
                    if (!available) {
                        log.debug("Glasses not available for viewer {}: {}", viewer.getId(), opId);
                        metricsCollector.recordGlassesUnavailable(viewer.getId());
                    }
                    return available;
                }).join();
        } catch (Exception e) {
            log.warn("Failed to check glasses availability for {}: {}", opId, e.getMessage());
            return false; // Graceful degradation
        }
    }
    
    private void tryPutOnGlassesWithRetry(Viewer viewer, String opId) {
        int attempts = 0;
        while (attempts < maxRetryAttempts) {
            try {
                boolean success = glassesService.putOnGlasses(viewer.getGlassesId())
                    .completeOnTimeout(false, Duration.ofMillis(1000))
                    .join();
                
                if (success) {
                    viewer.setGlassesOn(true);
                    log.info("Viewer {} put on glasses successfully: {}", viewer.getId(), opId);
                    metricsCollector.recordGlassesPutOn(viewer.getId());
                    return;
                }
                
                attempts++;
                log.debug("Failed to put on glasses, attempt {} for {}: {}", attempts, viewer.getId(), opId);
                
            } catch (Exception e) {
                attempts++;
                log.warn("Exception putting on glasses, attempt {} for {}: {}", 
                    attempts, viewer.getId(), e.getMessage());
            }
            
            if (attempts < maxRetryAttempts) {
                try {
                    Thread.sleep(50L * attempts); // Exponential backoff
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        log.warn("Failed to put on glasses after {} attempts for {}: {}", 
            maxRetryAttempts, viewer.getId(), opId);
        metricsCollector.recordGlassesFailure(viewer.getId());
    }
    
    // ========== КЭШИРОВАНИЕ ==========
    
    private Optional<ViewingResult> checkCache(String viewerId, String pictureId, String opId) {
        String cacheKey = generateCacheKey(viewerId, pictureId);
        ViewingCacheEntry entry = viewingCache.get(cacheKey);
        
        if (entry != null && !entry.isExpired()) {
            log.debug("Cache hit for {}: {}", cacheKey, opId);
            metricsCollector.recordCacheHit();
            return Optional.of(entry.getResult());
        }
        
        if (entry != null && entry.isExpired()) {
            viewingCache.remove(cacheKey);
            metricsCollector.recordCacheExpiration();
        }
        
        return Optional.empty();
    }
    
    private void cacheResult(String viewerId, String pictureId, ViewingResult result) {
        if (cacheTtlSeconds <= 0) return;
        
        String cacheKey = generateCacheKey(viewerId, pictureId);
        ViewingCacheEntry entry = new ViewingCacheEntry(result, cacheTtlSeconds);
        viewingCache.put(cacheKey, entry);
        metricsCollector.recordCachePut();
    }
    
    // ========== CIRCUIT BREAKER ==========
    
    private boolean isCircuitBreakerOpen() {
        if (!circuitBreakerOpen) return false;
        
        // Проверяем, можно ли закрыть circuit breaker
        if (Duration.between(lastCircuitBreakerCheck, Instant.now()).toMinutes() >= 1) {
            circuitBreakerOpen = false;
            lastCircuitBreakerCheck = Instant.now();
            log.info("Circuit breaker automatically closed after cooldown period");
        }
        
        return circuitBreakerOpen;
    }
    
    private void recordFailure(String viewerId, String pictureId) {
        String key = viewerId + ":" + pictureId;
        AtomicInteger counter = failureCounters.computeIfAbsent(key, k -> new AtomicInteger(0));
        
        if (counter.incrementAndGet() >= circuitBreakerThreshold) {
            circuitBreakerOpen = true;
            log.error("Circuit breaker OPENED due to {} consecutive failures for {}", 
                circuitBreakerThreshold, key);
            metricsCollector.recordCircuitBreakerOpen();
        }
    }
    
    private void recordSuccess(String opId) {
        // Сброс счетчиков ошибок при успехе
        failureCounters.clear();
        if (circuitBreakerOpen) {
            circuitBreakerOpen = false;
            log.info("Circuit breaker CLOSED after successful operation: {}", opId);
            metricsCollector.recordCircuitBreakerClosed();
        }
    }
    
    // ========== УТИЛИТЫ ==========
    
    private void validateInput(String viewerId, String pictureId, String opId) {
        if (viewerId == null || viewerId.trim().isEmpty()) {
            throw new ValidationException("Viewer ID cannot be empty", opId);
        }
        if (pictureId == null || pictureId.trim().isEmpty()) {
            throw new ValidationException("Picture ID cannot be empty", opId);
        }
        if (viewerId.length() > 100) {
            throw new ValidationException("Viewer ID too long", opId);
        }
    }
    
    private boolean isGracefulDegradationAllowed() {
        return gracefulDegradationEnabled && 
               successfulViewings.longValue() > failedViewings.longValue() * 10;
    }
    
    private ViewingMetrics collectMetrics(Viewer viewer, Picture picture, 
                                         Instant startTime, boolean wasFunny, String opId) {
        long duration = Duration.between(startTime, Instant.now()).toMillis();
        
        return ViewingMetrics.builder()
            .operationId(opId)
            .viewerId(viewer.getId())
            .pictureId(picture.getId())
            .durationMs(duration)
            .wasFunny(wasFunny)
            .glassesWorn(viewer.hasGlassesOn())
            .laughCount(viewer.getLaughCount().get())
            .timestamp(Instant.now())
            .cacheSize(viewingCache.size())
            .failureRate(calculateFailureRate())
            .build();
    }
    
    private double calculateFailureRate() {
        long total = totalViewings.longValue();
        if (total == 0) return 0.0;
        return (double) failedViewings.longValue() / total * 100;
    }
    
    private String generateOperationId(String viewerId, String pictureId) {
        return String.format("VIEW-%s-%s-%s-%d",
            viewerId.substring(0, Math.min(8, viewerId.length())),
            pictureId.substring(0, Math.min(8, pictureId.length())),
            UUID.randomUUID().toString().substring(0, 8),
            System.currentTimeMillis() % 10000
        );
    }
    
    private String generateCacheKey(String viewerId, String pictureId) {
        return viewerId + "::" + pictureId;
    }
    
    private void sendAnalyticsAsync(Viewer viewer, Picture picture, 
                                   ViewingResult result, String opId) {
        CompletableFuture.runAsync(() -> {
            try {
                analyticsService.trackViewing(
                    viewer.getId(),
                    picture.getId(),
                    result.wasFunny(),
                    result.glassesWorn(),
                    opId
                );
            } catch (Exception e) {
                log.warn("Failed to send analytics for {}: {}", opId, e.getMessage());
            }
        });
    }
    
    private void startMetricsCollector() {
        // Запуск фонового сборщика метрик
        new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    Thread.sleep(60000); // Каждую минуту
                    
                    double failureRate = calculateFailureRate();
                    log.info("Viewing metrics - Total: {}, Success: {}, Failed: {}, Failure Rate: {:.2f}%, Cache Size: {}, Circuit Breaker: {}",
                        totalViewings.longValue(),
                        successfulViewings.longValue(),
                        failedViewings.longValue(),
                        failureRate,
                        viewingCache.size(),
                        circuitBreakerOpen ? "OPEN" : "CLOSED"
                    );
                    
                    if (failureRate > 10.0 && !circuitBreakerOpen) {
                        log.warn("High failure rate detected: {:.2f}%", failureRate);
                    }
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                } catch (Exception e) {
                    log.error("Error in metrics collector: {}", e.getMessage());
                }
            }
        }, "metrics-collector").start();
    }
}

// ========== ВСПОМОГАТЕЛЬНЫЕ КЛАССЫ (в том же файле для простоты) ==========

class ViewingCacheEntry {
    private final ViewingResult result;
    private final Instant expiryTime;
    
    public ViewingCacheEntry(ViewingResult result, long ttlSeconds) {
        this.result = result;
        this.expiryTime = Instant.now().plusSeconds(ttlSeconds);
    }
    
    public ViewingResult getResult() { return result; }
    public boolean isExpired() { return Instant.now().isAfter(expiryTime); }
}

record ViewingResult(
    String viewerId,
    String pictureName,
    boolean success,
    boolean degraded,
    boolean skipped,
    String errorCode,
    String errorMessage,
    boolean wasFunny,
    boolean glassesWorn,
    int laughCount,
    ViewingMetrics metrics
) {
    static ViewingResult success(String viewerId, String pictureName, 
                                boolean wasFunny, boolean glassesWorn, 
                                int laughCount, ViewingMetrics metrics) {
        return new ViewingResult(
            viewerId, pictureName, true, false, false, 
            null, null, wasFunny, glassesWorn, laughCount, metrics
        );
    }
    
    static ViewingResult failure(String errorCode, String errorMessage) {
        return new ViewingResult(
            null, null, false, false, false, 
            errorCode, errorMessage, false, false, 0, null
        );
    }
    
    static ViewingResult skipped(String reasonCode, String reason) {
        return new ViewingResult(
            null, null, false, false, true, 
            reasonCode, reason, false, false, 0, null
        );
    }
    
    static ViewingResult degraded(String errorCode, String errorMessage) {
        return new ViewingResult(
            null, null, false, true, false, 
            errorCode, errorMessage, false, false, 0, null
        );
    }
}

// Минимальные интерфейсы для демонстрации
interface PictureRepository {
    Optional<Picture> findById(String id);
    Picture save(Picture picture);
}

interface ViewerRepository {
    Optional<Viewer> findById(String id);
    Viewer save(Viewer viewer);
}

interface GlassesService {
    boolean isAvailable();
    CompletableFuture<Boolean> checkAvailability(String glassesId);
    CompletableFuture<Boolean> putOnGlasses(String glassesId);
}

interface AnalyticsService {
    void trackViewing(String viewerId, String pictureId, boolean wasFunny, 
                     boolean glassesWorn, String operationId);
}

interface MetricsCollector {
    void recordCacheHit();
    void recordCachePut();
    void recordCacheExpiration();
    void recordSkippedViewing(String viewerId, String reason);
    void recordGlassesUnavailable(String viewerId);
    void recordGlassesPutOn(String viewerId);
    void recordGlassesFailure(String viewerId);
    void recordViewingError(String errorCode);
    void recordUnexpectedError(Exception e);
    void recordOperationDuration(String operationId, long durationMs);
    void recordCircuitBreakerOpen();
    void recordCircuitBreakerClosed();
}

// Базовые исключения
class BusinessException extends RuntimeException {
    private final String errorCode;
    
    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public String getErrorCode() { return errorCode; }
}

class ValidationException extends BusinessException {
    public ValidationException(String message, String operationId) {
        super("VALIDATION_ERROR", message + " [opId: " + operationId + "]");
    }
}

class ViewerNotFoundException extends BusinessException {
    public ViewerNotFoundException(String message) {
        super("VIEWER_NOT_FOUND", message);
    }
}

class PictureNotFoundException extends BusinessException {
    public PictureNotFoundException(String message) {
        super("PICTURE_NOT_FOUND", message);
    }
}

class ViewingServiceException extends RuntimeException {
    public ViewingServiceException(String message, Throwable cause) {
        super(message, cause);
    }
}

class TemporaryServiceException extends RuntimeException {
    public TemporaryServiceException(String message) {
        super(message);
    }
}

// Простые модели для демонстрации
class Picture {
    private String id;
    private String name;
    private AtomicInteger viewCount = new AtomicInteger(0);
    private boolean funny;
    
    public String getId() { return id; }
    public String getName() { return name; }
    public boolean isFunny() { return funny; }
    public int getViewCount() { return viewCount.get(); }
    public void incrementViewCount() { viewCount.incrementAndGet(); }
    public void addViewerReaction(String viewerId, String reaction) {
        // Реализация добавления реакции
    }
}

class Viewer {
    private String id;
    private String name;
    private boolean sleeping;
    private AtomicInteger laughCount = new AtomicInteger(0);
    private String glassesId;
    private boolean glassesOn;
    
    public String getId() { return id; }
    public String getName() { return name; }
    public boolean isSleeping() { return sleeping; }
    public AtomicInteger getLaughCount() { return laughCount; }
    public void setLaughCount(int count) { laughCount.set(count); }
    public String getGlassesId() { return glassesId; }
    public boolean hasGlassesOn() { return glassesOn; }
    public void setGlassesOn(boolean glassesOn) { this.glassesOn = glassesOn; }
}

class ViewingMetrics {
    private String operationId;
    private String viewerId;
    private String pictureId;
    private long durationMs;
    private boolean wasFunny;
    private boolean glassesWorn;
    private int laughCount;
    private Instant timestamp;
    private int cacheSize;
    private double failureRate;
    
    // Builder pattern методы
    public static Builder builder() { return new Builder(); }
    
    static class Builder {
        private ViewingMetrics metrics = new ViewingMetrics();
        
        public Builder operationId(String opId) { metrics.operationId = opId; return this; }
        public Builder viewerId(String id) { metrics.viewerId = id; return this; }
        public Builder pictureId(String id) { metrics.pictureId = id; return this; }
        public Builder durationMs(long ms) { metrics.durationMs = ms; return this; }
        public Builder wasFunny(boolean funny) { metrics.wasFunny = funny; return this; }
        public Builder glassesWorn(boolean worn) { metrics.glassesWorn = worn; return this; }
        public Builder laughCount(int count) { metrics.laughCount = count; return this; }
        public Builder timestamp(Instant time) { metrics.timestamp = time; return this; }
        public Builder cacheSize(int size) { metrics.cacheSize = size; return this; }
        public Builder failureRate(double rate) { metrics.failureRate = rate; return this; }
        
        public ViewingMetrics build() { return metrics; }
    }
}

// Для circuit breaker (упрощённо)
class CircuitBreakerRegistry {
    public boolean isAllowed(String service) { return true; }
}
